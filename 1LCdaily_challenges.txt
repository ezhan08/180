1.reverse string- 344

class Solution {
public:
    void reverseString(vector<char>& s) {
        int n=s.size();
        int l=0, r=n-1;
        while(l<r){
            swap(s[l++], s[r--]);
        }
    }
};

2. 680

class Solution:
    def validPalindrome(self, s: str) -> bool:
        l,r=0, len(s) -1
        while l<r:
            if s[l] != s[r]:
                skipl, skipr = s[l+1:r+1], s[l:r]
                return (skipl == skipl[::-1] or skipr == skipr[::-1])
            l+=1
            r-=1
        return True


3. 31

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        if(nums.size()<=1) return;
        int i=nums.size()-1,j;
        for(j=nums.size()-2;j>=0;j--){
            if(nums[j] < nums[j+1])break;
        }
        if(j>=0){
            
                while(nums[i] <= nums[j]) i--;
                swap(nums[i], nums[j]);
            
        }
        reverse(nums.begin() + j+1, nums.end());
    }
};


4. 1721

We traverse the list until we reach the kth node.
Then we set "kth" to that node to remember it, set ptr2 to head and continue traversing the list, while we move both ptr1 and ptr2.
When ptr1 reaches the end - ptr2 is on the (n-k)th node.
Now we swap "kth" and "ptr2" and we're done!

class Solution {
public:
    ListNode* swapNodes(ListNode* head, int k) {
        ListNode *ptr1 = head, *ptr2 = head, *kth = NULL;
        while (--k)
            ptr1 = ptr1->next;
        
        kth = ptr1;
        ptr1 = ptr1->next;
        
        while (ptr1) {
            ptr1 = ptr1->next;
            ptr2 = ptr2->next;
        }
        swap(ptr2->val, kth->val);
        return head;
    }
};
