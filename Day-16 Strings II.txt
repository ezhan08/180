1. Z function

class Solution {
public:
    int strStr(string haystack, string needle) {
        if(needle.size()==0) return 0;
        string s=needle+"+"+haystack;
        int n=s.size();
        vector<int> z(n);
        for(int i=1;i<n;i++){
            int j=z[i-1];
            while(j>0 and s[j]!=s[i]) j=z[j-1];
            if(s[i]==s[j]) j++;
            z[i]=j;
        }
        for(int i=needle.size()+1;i<n;i++){
            if(z[i]==needle.size()) return i-needle.size()-needle.size();
        }
        return -1;
    }
};

2. kmp algo/lps

class Solution {
  private:
    vector < int > kmpProcess(string needle) {
      int n = needle.size();
      vector < int > lps(n, 0);
      int len = 0;
      lps[0] = 0;
      int i = 1;
      while (i < n) {
        if (needle[i] == needle[len]) {
          len++;
          lps[i] = len;
          i++;
        } else {
          if (len == 0) {
            lps[i] = 0;
            i++;
          } else {
            len = lps[len - 1];
          }
        }

      }
      return lps;
    }

  public:
    int strStr(string haystack, string needle) {
      int m = haystack.size(), n = needle.size();
      if (!n) {
        return 0;
      }
      vector < int > lps = kmpProcess(needle);
      for (int i = 0, j = 0; i < m;) {
        if (haystack[i] == needle[j]) {
          i++, j++;
        }
        if (j == n) {
          return i - j;
        }
        if (i < m && haystack[i] != needle[j]) {
          j ? j = lps[j - 1] : i++;
        }
      }
      return -1;
    }
};

3. minimum no of chars at the beginning to make palindrome


 // we will match with lps array, in reverse we would check max length suffix which is a prefix in original string
      // if input is AACECAAAA make it of the form as given : Original + $ + reverse
    // AACECAAAA$AAAACECAA
    // 0100012220122234567  -> lps array
    // the last index of this lps array tells how much length of the original string from starting is a palindrome, we only need to add the remaining letters in the start to make a palondrome
    
    

int Solution::solve(string s) {
   
    string r = s;
    reverse(r.begin(),r.end());
    int orgL=s.length();
    s = s + "$" + r;
    int l = s.length();
    int lps[l]; // lps array
    int len=0,i=1;
    lps[0]=0;
    while(i<l){
        if(s[len]==s[i]){
            len++;
            lps[i]=len;
            i++;
        }
        else
        {
            if(len!=0){
                len=lps[len-1];
            }
            else{
                len=0;
                lps[i]=0;
                i++;
            }
        }
    }
    int suff = lps[l-1]; // last index 
    return orgL-suff; // original length - last index of lps array
}
