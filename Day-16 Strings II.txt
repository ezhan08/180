1. Z function

class Solution {
public:
    int strStr(string haystack, string needle) {
        if(needle.size()==0) return 0;
        string s=needle+"+"+haystack;
        int n=s.size();
        vector<int> z(n);
        for(int i=1;i<n;i++){
            int j=z[i-1];
            while(j>0 and s[j]!=s[i]) j=z[j-1];
            if(s[i]==s[j]) j++;
            z[i]=j;
        }
        for(int i=needle.size()+1;i<n;i++){
            if(z[i]==needle.size()) return i-needle.size()-needle.size();
        }
        return -1;
    }
};

2. kmp algo/lps

class Solution {
  private:
    vector < int > kmpProcess(string needle) {
      int n = needle.size();
      vector < int > lps(n, 0);
      int len = 0;
      lps[0] = 0;
      int i = 1;
      while (i < n) {
        if (needle[i] == needle[len]) {
          len++;
          lps[i] = len;
          i++;
        } else {
          if (len == 0) {
            lps[i] = 0;
            i++;
          } else {
            len = lps[len - 1];
          }
        }

      }
      return lps;
    }

  public:
    int strStr(string haystack, string needle) {
      int m = haystack.size(), n = needle.size();
      if (!n) {
        return 0;
      }
      vector < int > lps = kmpProcess(needle);
      for (int i = 0, j = 0; i < m;) {
        if (haystack[i] == needle[j]) {
          i++, j++;
        }
        if (j == n) {
          return i - j;
        }
        if (i < m && haystack[i] != needle[j]) {
          j ? j = lps[j - 1] : i++;
        }
      }
      return -1;
    }
};
